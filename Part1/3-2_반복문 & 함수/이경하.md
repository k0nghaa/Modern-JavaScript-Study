# 1. 반복문

## while 반복문

```jsx
while (조건) { // 조건 - 모든 종류의 표현식, 변수 OK
	동작;
} // 조건이 truthy 이면 동작(반복) 실행 (즉, falsy값 나왔을 때 종료)

// or
let i = 3;
while (i) alert(i--); // 본문이 한 줄이면 {중괄호} 생략 가능
```

## do…while 반복문

```jsx
do {
	동작;
} while (조건);
```

- do…while 본문(동작)이 먼저 실행되고, 조건 확인 후 truthy 동안 반복
- 따라서 조건이 truthy, falsy인지 상관없이, 동작을 최소한 한 번이라도 실행하고 싶을 때만 사용해야 함!

## for 반복문

```jsx
for (초기화; 조건; 추가 동작) { 
	동작;
} // 초기화와 추가 동작 생략 가능. 그러나 반드시 ()안엔 **세미콜론(;)이 두 개** 있어야 함

// ex1. 변수 선언
let i = 0; // 변수 선언은 '인라인'(for문 안에서만 접근)으로도 가능하고,

for (i = 0; i < 3; i++) { // 반복문 밖에 정의되어있는 변수 사용도 가능하다
	alert(i); // 0, 1, 2
}
alert(i); // 3, 반복문 밖에서 선언한 변수는 사용될 수 있음

// ex2. 구성 요소 생략
let i = 0; // i 선언 & 값 할당

for(; i < 3;) {
	alert( i++ ); // 추가동작 alert에서 진행
}
```

- *참고)* 무한 반복문 `for ( ; ; ) {}` 을 현업에서 사용하는 경우
    - 서버나 프로세스 계속 대기 및 처리.
    게임 개발 - 프레임 단위로 업데이트와 렌더링 반복하는 루프 돌림.
    네트워크 프로그래밍에서 데이터 올 때까지 계속 대기(무한 반복)하다 데이터 수신 후 조건 만족 시 종료.
    …
    - 조건을 바깥에 안 쓰고 내부에서 break/return으로 제어하는 경우가 대부분임
    - cf. 무한 반복문 `while(true)`

## 특별 지시자 break, continue

- 반복문 안에서만 사용

### break - 반복문 빠져나오기

- break; 이후 반복문 자체 즉시 중단 
→ 제어 흐름 반복문 아래 첫 번째 줄로 이동

### continue - 다음 반복으로 넘어가기

- continue; 이후 현재 실행 중인 반복 멈추고 다음 조건(반복)으로 넘어감

```jsx
// ex.
for (let i = 0; i < 10; i++) {
	if (i % 2 == 0) continue;
	alert(i); // 1, 3, 5, 7, 9
}
```

### 삼항 연산자 `?` 에 break나 continue를 쓸 수 없다

- *표현식이 아닌 **문법 구조는 삼항 연산자 `?` 에 사용할 수 없다
    - 삼항 연산자는 값을 만들어야 함
    - *표현식: 실행하면 값이 나오는 것
    - **문법 구조: 값을 반환하지 않는 것(”행동”만 함)

## 레이블(label)

- 여러 개의 중첩 반복문을 한 번에 빠져나와야 하는 경우 쓰임

```jsx
lableName: for (조건) { // 레이블은 반드시 break나 continue 위에 있어야 함
	반복문 본문;
}
```

- `break <labelName>` - 레이블에 해당하는 반복문 빠져나오기
- `continue <lableName>` - 레이블이 붙은 반복문의 다음 반복 실행하기

## 반복문 비교

| while | 조건 확인 → 반복 시작 |
| --- | --- |
| do..while | 본문(첫번째 반복) 시작 → 조건 확인 |
| for (;;) | 조건 확인 → 반복 (+ 추가 세팅) |

# 2. switch 조건문

- 특정 변수를 다양한 상황에서 **비교**하고 싶을 때 사용
- **일치 비교**로 조건 확인
비교하려는 값과 case문의 값. **값과 형이 모두 같아야 case문 실행
변수와 조건의 자료형을 주의해서 챙길 것!**

```jsx
switch(변수) {
	case 'value1': // 변수 값과 case문의 값 'value1' 일치 비교
		동작 // 일치할 시, 동작. 아니면 case 'value2'로 넘어감
		[break;] // break 이후 조건문 종료
	case 'value2':
		동작
		[break;] // break 없으면 이어지는 case문 조건 부합하든 안하든 실행
	default: // 모든 case가 일치하지 않을 시, 실행 (필수 아님)
		동작
		[break;]
}

//case문은 한데 묶을 수 있다(같은 동작을 시키고 싶을 경우 사용)
let a = 1;
switch (a) {
	case 1:
		alert('정답');
		break;
	case 2:
	case 3:
		alert('오답');
		alert('다시 한번 생각해보세요'); //2나 3 입력 시, break 만나기 전까지의 동작 실행. 즉, alert 둘다(순서대로) 실행됨
		break;
	default:
		alert('결과가 이상하네요');
}
```

# 3. 함수

- 중복 없이 유사한 **동작**을 하는 코드를 여러 번 호출하기 위하여 사용
즉, 함수는 “동작”을 나타내는 값
- 규칙
    - 함수는 동작 하나만 담당해야 함
    - 함수를 간결하게 만들어야 테스트와 디버깅이 쉬워짐
    - 함수는 값이기 때문에 변수에 할당할 수 있다 — ***함수 표현식
    - 괄호( 함수이름**()** )가 있어야만 함수 호출됨
    즉, 함수 반환 값을 얻고 싶다면 () 사용, 함수 자체를 불러오고 싶다면 함수이름만 사용
    - 함수는 언제나 복사된 값을 사용한다
    함수 호출 → 함수에 전달된 인자는 지역변수인 매개변수에 복사 → 함수에서 복사된 값 사용
    - 함수는 항상 무언가를 반환함
        
         `return`문이 없는 경우는 `undefined`반환
        

## 함수 선언

```jsx
// 함수 선언
function 함수이름(매개변수(, 매개변수, 매개변수...)) {
	명령; // 함수 본문
	...
}

// 함수 호출
함수이름(); // 함수 본문 실행
함수이름(); 
```

- 함수 내에서 선언한 변수 = 로컬 변수, 지역 변수
함수 밖에서 선언한 변수 = 글로벌 변수, 전역 변수, 외부 변수
- 규칙
    1. 같은 이름의 지역 변수가 없을 때만 외부 변수에 접근할 수 있다(외부 변수는 가려짐)
        - 전역 변수와 지역 변수에 같은 이름을 사용할 경우,
        지역 변수는 지역 스코프 안에서 생성된 것으로 함수 안에서 사용 및 실행되고 **사라짐** → 스코프 밖에서는 전역 변수 사용
            - 이런 규칙이 생긴 이유?
            자바스크립트에서 변수 이름을 찾을 때, 스코프 체인을 위에서부터 아래로 검색함
            1) 가장 가까운 스코프(현재 함수의 지역 스코프)에서 찾음
            2) 없으면 한 단계 바깥 스코프로 이동
            3) 계속 없으면 전역 스코프까지 올라감
    2. 함수 내부에서 외부 변수에 접근 및 수정 가능하다
    3. 프로젝트 전반에 사용되는 데이터가 아닌 이상, 전역 변수는 되도록 사용하지 않는다
    4. 함수 선언문은 선언된 블록 안에서만 접근할 수 있다(블록 스코프를 가진다)

> **함수 이름 규칙**
- 함수가 어떤 동작을 하는지 축양해서 설명해 주는 동사를 접두어로 붙여 만든다
ex. show… — 무언가를 보여줌
      get… — 값을 반환함
     calc… — 무언가를 계산함
     create… — 무언가를 생성함
     check… — 무언가를 확인하고 불린값을 반환함
> 

## 매개변수

- 임의의 데이터를 함수 안에 전달하기 위해 사용 (⇒ 인자)
    - cf. 인수: 함수 호출할 때 매개변수에 전달되는 값(호출 시 쓰이는 용어)
         인자: 함수 선언 방식 괄호 사이에 있는 변수(선언 시 쓰이는 용어)
- 매개변수도 변수!!!임을 잊지 말 것
- **함수 호출 시 매개변수에 인수를 전달하지 않으면 undefined 할당(error X)**

## 기본값

- 규칙
    1. 매개변수에 값 전달하지 않아도 undefined가 되지 않게 하기 위해 쓰임
    2. 매개변수에 값을 전달해도 그 값이 undefined와 엄격히 일치(`===`)한다면 기본값으로 할당됨

### 함수 선언 후 매개변수 기본값 설정하기

```jsx
if ( text === undefined) { // text는 할당하지않은 매개변수
	text = '기본값';
}
	
```

### `||` 나 `??` 사용해 매개변수 기본값 설정하기

```jsx
// || 사용
function showMessage(from, text) {
  // text의 값이 falsy면 기본값이 할당됨
  // 이 방식은 text == ""일 경우, text에 값이 전달되지 않은것과 같다고 간주합니다..
  text = text || 'no text given';
  ...
}

// ?? 사용 - falsy로 평가되는 값(ex. 0)들을 일반 값처럼 처리할 수 있음
function showCount(count) {
  alert(count ?? "unknown");
}

showCount(0); // 0
showCount(null); // unknown
showCount(); // unknown
```

## 지시자 return - 반환

- 실행 흐름: return 만남 → 함수 실행 즉시 중단 → 함수 호출한 곳에 값 반환
- 규칙
    - 함수 내 어디서든 사용 가능
    - return만 명시하는 것도 가능 — 이런 경우 함수가 즉시 종료됨
    - return문이 없거나 return 지시자만 있는 함수는 undefined 반환
    - return과 값 사이에 절대 새 줄을 삽입하지 말 것
    긴 값을 표현하고 싶을 땐 괄호 사용

## ***함수 표현식

```jsx
//sayHi() - 만약 여기서 이렇게 함수를 호출했다면 Error (TDZ이기 때문)

let sayHi = function() {
  alert("Hello");
}**;**
```

- 이름 없는 함수도 가능하다
그러나 변수에 할당된 게 아니기 때문에 함수 표현식 바깥에선 접근할 수 없다
    
    ```jsx
    function ask(question, yes, no) {
      if (confirm(question)) yes()
      else no();
    }
    
    ask( // 이름 없는 함수(익명 함수) 예시
      "동의하십니까?",
      function() { alert("동의하셨습니다."); },
      function() { alert("취소 버튼을 누르셨습니다."); }
    );
    ```
    

## 함수 선언문 VS 함수 표현식

- **함수 선언문**은 호이스팅 됨
→ 스크립트가 실행되기 전에 메모리에 미리 함수 등록
→ 따라서, 선언 위에서도 호출 가능함(전역 또는 함수 스코프에서 사용)
- **함수 표현식**은 let의 변수로 호이스팅은 되지만, 초기화 전에는 사용할 수 없음(대입 이후에만 호출 가능)

### 콜백 함수(=콜백)

- 함수를 함수의 인수로 전달하고, 필요하다면 인수로 전달한 그 함수를 나중에 호출하는 것

## 화살표 함수

- 함수 표현식을 간결하게 쓰기 위해 사용

```jsx
let func = (arg1, arg2, ...argN) => expression(표현식)
/* 아래 함수의 축약 버전임
let func = function(arg1, arg2, ...argN) {
  return expression;
};
*/

// ex1. 적용
let sum = (a, b) => a + b;
alert( sum(1, 2) ); // 3

// ex2. 인수가 하나밖에 없을 때 괄호 생략 가능
let double = n => n * 2;
alert( double(3) ); // 6

// ex3. 인수가 하나도 없을 땐 괄호 안 비움 - 괄호 생략X
let sayHi = () => alert("안녕하세요!");
sayHi();

// ex4. 평가해야 할 표현식이나 구문이 여러 개일 때 중괄호 사용
let sum = (a, b) => {
  let result = a + b;
  return result; // 중괄호를 사용했다면 return 지시자로 결괏값 반환해줘야 함
};
alert( sum(1, 2) ); // 3
```

---

# 인사이트

## 💡새로 알게 된 부분

- switch문에 case 에는 값을 써야한다(조건식 안됨)
- 같은 이름의 지역 변수가 없을 때만 외부 변수에 접근할 수 있다(외부 변수는 가려짐)
    - 전역 변수와 지역 변수에 같은 이름을 사용할 경우,
    지역 변수는 지역 스코프 안에서 생성된 것으로 함수 안에서 사용 및 실행되고 **사라짐** → 스코프 밖에서는 전역 변수 사용
        - 이런 규칙이 생긴 이유?
        자바스크립트에서 변수 이름을 찾을 때, 스코프 체인을 위에서부터 아래로 검색함
        1) 가장 가까운 스코프(현재 함수의 지역 스코프)에서 찾음
        2) 없으면 한 단계 바깥 스코프로 이동
        3) 계속 없으면 전역 스코프까지 올라감
- 인수와 인자 개념이 불분명했는데, 정확하게 이해하게 됨
    - 매개변수는 함수 선언 방식 괄호 사이에 있는 변수(선언 시 쓰이는 용어)
    - 인수는 함수를 호출할 때 매개변수에 전달되는 값(호출 시 쓰이는 용어)
- 함수 이름 짓는 자세한 방법을 알게 되었다! — 항상 어려웠던 것

```jsx
//예시
showMessage(..)     // 메시지를 보여줌
getAge(..)          // 나이를 나타내는 값을 얻고 그 값을 반환함
calcSum(..)         // 합계를 계산하고 그 결과를 반환함
createForm(..)      // form을 생성하고 만들어진 form을 반환함
checkPermission(..) // 승인 여부를 확인하고 true나 false를 반환함
```

- 함수 선언문과 함수 표현식 차이를 이해했다

## 🔍공부할 것

- 함수 표현식에 대해 익숙해져야 할 거 같다. 특히 익명함수 작성 예시에 대해 알아볼 것
- 일반적 기초적인 작성법 외, 
?를 사용하거나 || 사용하거나, while 안에 if가 들어간다거나 하면 작성할 줄 모름 . . .
