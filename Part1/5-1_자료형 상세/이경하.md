# 1️⃣ 배열

- 순서가 있는 컬렉션을 저장하기 위한 자료구조

### 기본 규칙

- 객체와 비슷한 점이 많다
( 선언, 특정 요소 얻는 법, 요소 추가 및 수정법 등)
    
    ```jsx
    let arr = new Array(); // 잘 사용되지 않음
    let arr = []; // 대괄호 안에 초기 요소를 넣을 수 있다
    
    // 배열 내 특정 요소 얻기
    let fruits = ["사과", "오렌지", "자두"];
    alert( fruits[0] ); // 사과
    // 요소 수정
    fruits[2] = '배'; // ["사과", "오렌지", "배"]
    // 요소 추가
    fruits[3] = '레몬'; // ["사과", "오렌지", "배", "레몬"]
    // 요소 전체 출력
    alert( fruits ); // 사과,오렌지,배,레몬
    // 배열 요소의 자료형에는 제약이 없음
    let arr = [ '사과', { name: '이보라' }, true, function() { alert('안녕하세요.'); } ];
    ```
    
    - new Array(); 를 잘 사용하지 않는 이유
        - 숫자형 인수를 넣어 배열을 만들면,
        해당 배열엔 요소가 없는 반면 길이는 인수와 같아진다
- 배열을 `length` 프로퍼티를 사용할 수 있다
    - 배열 요소 개수 확인 가능
    - 가장 큰 인덱스에 1을 더한 값임(아래 예시 확인)
    
    ```jsx
    let fruits = [];
    fruits[123] = "사과";
    
    alert( fruits.length ); // 124
    ```
    
    - length 프로퍼티를 이용해 값을 감소시키면 배열이 잘림
    —> `arr.length = 0;` 을 사용하면 간단하게 배열을 비울 수 있음
- 참조를 통해 복사됨
- 배열을 다루는 잘못된 방법
    - `arr.test = 5` 같이 숫자가 아닌 값을 프로퍼티 키로 사용하는 경우
    - `arr[0]`과 `arr[1000]`만 추가하고 그사이에 아무런 요소도 없는 경우
    - `arr[1000]`, `arr[999]`같이 요소를 역순으로 채우는 경우
- 배열엔 toString 메서드가 구현되어 있다.
배열 호출 시 요소를 쉼표로 구분한 문자열이 반환되는 이유

### 반복문

- for
- for..of
    
    > 배열도 객체의 일부이므로 for..in 문을 쓸 수 있지만,
    성능을 생각하면 가능한 쓰지 않는 게 좋다
    > 

### 자료 구조

배열을 사용해 만들 수 있는 대표적인 자료구조

- 큐(queue)
큐에서 사용하는 주요 연산 — push, shift
가장 먼저 집어넣은 요소가 먼저 나옴(=선입선출)
- 스택(stack)
스택에서 사용하는 주요 연산 — push, pop
스택은 **한쪽 끝**에 요소를 더하거나 뺄 수 있게 해주는 자료구조로,
가장 나중에 집어넣은 요소가 먼저 나옴(=후입선출)

# 2️⃣ 배열과 메서드

## 요소 추가 및 제거 메서드

### `pop`

배열 끝 요소를 제거하고 제거한 요소를 반환

### `push(…)`

배열 끝에 요소를 추가

### `shift`

배열 앞 요소를 제거하고 제거한 요소를 반환

### `unshift(…)`

배열 앞 요소를 추가

### `splice`

`arr.splice(index[, deleteCount, elem1, ..., elemN])`

배열 속 요소를 추가, 삭제, 교체

### `slice`

`arr.slice([start], [end])`

start 인덱스부터 end(end 제외) 인덱스까지의 요소를 복사한 새로운 배열 반환

**인수를 하나도 넘기지 않고 호출하면 배열의 복사본을 만들 수 있다**

### `concat`

`arr.concat(arg1, arg2...)`

기존 배열의 요소를 사용해 새로운 배열을 만들거나,
기존 배열에 요소를 추가

- 인자로 받은 유사 배열 객체에 `Symbol.isConcatSpreadable` 이 있으면, 객체 전체가 아닌 객체 프로퍼티의 값이 더해짐

### `fill`

`arr.fill(value, start, end)`

start 부터 end까지 value를 채워넣음

### `copyWithin`

`arr.copyWithin(target, start, end)`

start부터 end까지 요소를 복사하고, 복사한 요소를 target에 붙여넣음

기존 요소가 있다면 덮어씀

## 반복작업

### `forEach`

```jsx
arr.forEach(function(item, index, array) {
  // 요소에 무언가를 할 수 있습니다.
});
```

주어진 함수를 배열 요소 각각에 대해 실행

단순히 배열의 각 요소에 대해 지정된 작업을 수행하는 데 사용될 뿐,
새로운 값을 반환하지는 않음 — forEach 메서드 자체의 반환값은 항상 undefined

## 배열 탐색

### `indexOf (+lastIndexOf)`

`arr.indexOf(item, from)`

인덱스 from부터 시작해 item(요소)을 찾는 메서드

요소 발견하면 해당 요소의 인덱스 반환,
발견 못하면 -1 반환

lastIndexOf는 검색을 끝에서부터 시작

### `includes`

`arr.includes(item, from)`

인덱스 from부터 시작해 item이 있는지 검색(일치비교(===)하여 찾음)

해당 요소의 유무를 불린 형태로 반환

### `find(+ findIndex)`

객체로 이루어진 배열이 있을 때, 
배열 내 특정 조건에 부합하는 객체 찾고 해당 요소 반환

```jsx
let result = arr.find(function(item, index, array) {
  // true가 반환되면 반복이 멈추고 해당 요소를 반환합니다.
  // 조건에 해당하는 요소가 없으면 undefined를 반환합니다.
});
```

findIndex는 조건에 맞는 요소의 인덱스를 반환

### `filter`

객체로 이루어진 배열이 있을 때,
배열 내 특정 조건에 충족하는 요소가 여러 개일 때

```jsx
let results = arr.filter(function(item, index, array) {
  // 조건을 충족하는 요소는 results에 순차적으로 더해집니다.
  // 조건을 충족하는 요소가 하나도 없으면 빈 배열이 반환됩니다.
});
```

### `some(fn)`

함수의 반환 값을 true로 만드는 요소가 하나라도 있는지 여부 확인

### `every(fn)`

모든 요소가 함수의 반환 값을 true로 만드는지 여부 확인

## 배열 변형

### `map` ⭐

배열 요소 전체를 대상으로 함수를 호출하고, 함수 호출 결과를 배열로 반환

```jsx
let result = arr.map(function(item, index, array) {
  // 요소 대신 새로운 값을 반환합니다.
});
```

### `sort(fn)`

배열의 요소를 정렬

배열 자체가 변경됨

`arr.sort(function(a, b) { return a - b; }); // 오름차순 정렬`

`arr.sort(function(a, b) { return b - a; }); // 내림차순 정렬`

문자열엔 `str.localeCompare` 를 사용해 비교하는 게 좋다

### `reverse`

요소를 역순으로 정렬

### `split(delim)`

구분자 `delim` 을 기준으로 문자열을 쪼개주는 메서드

```jsx
// 예시
let names = 'Bilbo, Gandalf, Nazgul';

let arr = names.split(', ');

for (let name of arr) {
  alert( `${name}에게 보내는 메시지` ); // Bilbo에게 보내는 메시지
}

// 빈 문자열을 지정하면 글자 단위로 분리
let str = "test";

alert( str.split('') ); // t,e,s,t
```

### `join`

인수를 사용해 배열 요소를 모두 합친 후 하나의 문자열로 만들어주는 메서드

### `reduce`(+ `reduceRight`)

배열을 기반으로 값 하나(각 인수를 누적)를 도출함

```jsx
let value = arr.reduce(function(accumulator, item, index, array) {
  // ...
}, [initial]);
```

reduceRight는 배열의 오른쪽부터 연산 수행

## 배열 여부 알아내기

### `Array.isArray(value)`

value가 배열인지에 대한 여부를 불린 형태로 반환

## 배열 메서드와 ‘thisArg’

- 함수를 호출하는 대부분의 배열 메서드(sort 제외)는 thisArg 매개변수를 옵션으로 받을 수 있다
- `thisArg` ⇒ `func`의 `this`

# 💡새로 알게 된 것

- pop과 shift 메서드가 배열의 끝 요소를 제거 뿐만 아니라 반환도 해준다는 것
- length 프로퍼티는 배열의 길이를 나타내주며 정확히는 가장 큰 인덱스에 1을 더한 값임

# 👀 궁금한 것

- 배열 내 요소를 대상으로 반복 작업을 하는 forEach, for of, map 실무 예시 차이
