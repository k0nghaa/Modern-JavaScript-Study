메서드와 this

객체 지향 프로그래밍 : 객체를 사용하여 개체를 표현하는 방식
객체에게 능력부여를 위해서는 메서드를 우선 만들어야 한다.
[
user.sayHi = function() {
  alert("안녕하세요!");
};]

예시에선 user에 할당된 sayHi가 메서드를 뜻함.

메서드 단축 구문
// 단축 구문 미사용
user = {
  sayHi: function() {
    alert("Hello");
  }
};
// 단축 구문 사용
user = {
  sayHi() { // "sayHi: function()"과 동일합니다.
    alert("Hello");
  }
};

두 객체는 동일하게 동작함 

객체에 저장된 정보에 접근하기 위해선 메서드 내부에서 'this' 키워드를 사용하면 접근가능
alert(객체이름.name);

꼭 this를 사용하지 않고 외부 변수를 참조해 객체에 접근하는것도 가능하나 예상치 못한 에러가 발생할수 있음.

자바스크립트의 this는 다른 프로그래밍 언어의 this와 동작 방식이 다름.
자바스크립트에선 모든 함수에 this를 사용할수 있음.

화살표 함수 (=>) 

일반 함수와 달리 고유한 this를 가지지 않음.
화살표 함수에서 this를 참조하면, 화살표 함수가 아닌 '평범함' 외부 함수에서 this 값을 가져온다.
별개의 this가 만들어지는 건 원하지 않고, 외부 컨텍스트에 있는 this를 이용하고 싶은 경우 화살표 함수가 유용함.


new 연산자와 생성자 함수

객체 리터럴 {...}을 사용하면 객체를 만들 수 있다.
new 연산자와 생성자 함수를 사용하면 유사한 객체 여러개를 쉽게 만들 수 있음.

생성자 함수는 두가지 관례를 따른다. 
1. 함수 이름의 첫 글자는 대문자로 시작한다.
2. 반드시 'new' 연산자를 붙여 실행한다.
재사용할 수 있는 객체 생성 코드를 구현한다.
모든 함수는 생성자 함수가 될 수 있다는 점을 항상 생각하기. new를 붙여 실행한다면 어떤 함수라도 알고리즘이 실행됨.
생성자 함수를 이용하기 위해선 '첫글자가 대문자'인 함수로 작성하여 new를 붙여 실행해야함.

익명 생성자 함수로 감싸기
let user = new function() {
  this.name = "John";
  this.isAdmin = false;

  // 사용자 객체를 만들기 위한 여러 코드.
  // 지역 변수, 복잡한 로직, 구문 등의
  // 다양한 코드가 여기에 들어갑니다.
};

new.target과 생성자 함수 ( 자주 쓰이지 않음 )

new.target 프로퍼티를 사용하면 함수가 new와 함께 호출되었는지 아닌지를 알 수 있습니다.
호출했다면 undefined 반환
new와 함께 호출한 경우엔 new.target 함수 자체를 반환

생성자 함수엔 보통 return문이 없다. 반환해야할것은 this에 저장되고 자동 반환되기때문에.
하지만 return문이 있다면 !
1. 객체를 return 한다면 this 대신 객체가 반환됩니다.
2. 원시형을 return 한다면 return문이 무시됨.

function BigUser() {

  this.name = "원숭이";

  return { name: "고릴라" };  // <-- this가 아닌 새로운 객체를 반환함
}

alert( new BigUser().name );  // 고릴라
1. 객체를 return 한다면 this 대신 객체가 반환됩니다.

function SmallUser() {

  this.name = "원숭이";

  return; // <-- this를 반환함
}

alert( new SmallUser().name );  // 원숭이
2. 원시형을 return 한다면 return문이 무시됨.

메서드를 더해주는것도 가능함.

function User(name) {
  this.name = name;
//예시
  this.sayHi = function() {
    alert( "제 이름은 " + this.name + "입니다." );
  };
}

let bora = new User("이보라");

bora.sayHi(); // 제 이름은 이보라입니다.

/*
bora = {
   name: "이보라",
   sayHi: function() { ... }
}
*/
알게된점
new.target 활용하여 new와 함께 호출되었는지 여부를 확인할수 있다.
new 없이 호출할 경우 : undefined
new와 함께 호출할 경우: new.target은 해당 생성자 함수 자기 자신을 가리킴.
