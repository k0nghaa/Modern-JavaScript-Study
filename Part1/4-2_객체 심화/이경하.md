# 1️⃣ 원시값의 메서드

- 원시값도 객체처럼 다룰 수 있다(null, undefined 제외)
- 원시값은 원시 값 그대로 단일 값 형태를 유지 → 원시값이 메서드나 프로퍼티에 접근할 수 있도록 특수한 객체 “원시 래퍼 객체”를 만들어줌 → 특별한 객체는 사용 후 파괴되고 원시값만 남음
- ex) 
`str.toUpperCase/toLowerCase()` — 인수로 받은 문자열의 모든 글자로 대문자/소문자로 바꿔주는 메서드
`n.toFixed()` — 원하는 자리에서 소수점 아래 숫자를 반올림해주는 메서드

# 2️⃣ 숫자형

- 규칙
    - 빈 문자열이나 공백만 있는 문자열은 모든 숫자 관련 내장 함수에서 0으로 취급된다
- 다양한 숫자 표현법
    - 10억 ⇒ ‘1bn’
    73억 ⇒ ‘7.3bn’
    - ‘e’
    10억 ⇒ 1e9
    0.000001 ⇒ 1e-6
    - 16진수 — 0x
    8진수 — 0o
    2진수 — 0b
- num.toString(base)
— base(2, 8.. ~ 36 / 기본값: 10)진법으로 num을 표현한 후 이를 문자형으로 변환해 반환
    
    > 숫자를 대상으로 메서드에 직접 호출하고 싶다면
    숫자 다음에 점 두개를 붙여야 한다 `..`
    점 하나는 소수점으로 인식
    > 
- Math 객체 — 어림수 구하기, 기타 수학 함수
    - `Math.floor` — 소수점 첫째 자리에서 내림(버림)
    - `Math.ceil` — 소수점 첫째 자리에서 올림
    - `Math.round` — 소수점 첫째 자리에서 반올림
    - `Math.trunc`(IE 지원X) — 소수부를 무시
    - `n-th` 번째 수를 기준으로 어림수를 구하고 싶을 때
        1. 10의 거듭제곱 수를 곱한 후,
        원하는 어림수 내장 함수를 호출하고
        처음 곱한 수를 다시 나누기
            
            ```jsx
            let num = 1.23456;
            
            alert( Math.floor(num * 100) / 100 ); 
            // 1.23456 -> 123.456 -> 123 -> 1.23
            ```
            
        2. 소수점 n번째 수까지의 어림수를 구한 후
        이를 **문자형**으로 반환해주는 메서드 `toFixed(n)` 사용하기
            
            ㄴ 반환 값이 문자열이기 때문에 소수부의 길이가 인수보다 작으면 끝에 0이 추가됨 → + 나 Number() 쓰면 숫자형으로 변환 가능
            
    - `Math.random()` — 0과 1 사이의 난수 반환(1 제외)
    - `Math.max/min(a,b,c …)` — 인수 중 최대/최솟값 반환
    - `Math.pow(n, power)` — n을 power번 거듭제곱한 값 반환
- 부정확한 계산
    - 숫자가 너무 커지만 Infinity로 처리됨
    - 소수를 계산했을 때 정밀도 손실이 있어 원하는 답을 얻지 못할 수 있다
    (소수나 분수를 대상으로 작업할 때 등호 비교를 피해야 하는 이유)
        
        해결 방법 
        1. toFixed(n) 메서드를 사용해 어림수를 만드는 방법
        
        ```jsx
        let sum = 0.1 + 0.2;
        alert( sum.toFixed(2) ); // 0.30 - 문자열로 반환됐기 때문에 0이 붙음 
        alert( +sum.toFixed(2) ); // 0.3
        ```
        
        1. 숫자에 임의로 정수로 바꾸고, 원하는 연산 후 다시 100(또는 더 큰 숫자)로 나누는 방법
- `isNaN`과 `isFinite`
    
    두 특수 숫자는 숫자형에 속하지만 정상적인 숫자는 아니기 때문에,
    정상적인 숫자와 구분하기 위한 특별한 함수가 존재함
    
    - `isNaN(value)` — 인수를 숫자로 변환한 다음 `NaN`인지 테스트
    NaN의 특징 — NaN은 자기 자신을 포함하여 그 어떤 값과도 같지 않다
    - `isFinite(value)` — 인수를 숫자로 변환하고 변환한 숫자가 `NaN/Infinity/-Infinity` 가 아닌 일반 숫자인 경우 `true` 반환
        
        사용 예시) 문자열이 일반 숫자인지 검증
        
- `parseInt`와 `parseFloat`
    
    불가능할 때까지 문자열에서 숫자를 읽고(왼쪽에서 오른쪽으로),
    읽는 도중 오류(숫자가 아닐때)가 발생하면 이미 수집된 숫자를 반환
    
    - parseInt(str, [radix—원하는 진수 지정 가능])는 정수 반환
    parseFloat는 부동 소수점 숫자 반환

# 3️⃣ 문자열

- 규칙
    - 문자열은 수정할 수 없다(ex. 중간 글자 하나만 수정)
- ``백틱
    1. 템플릿 리터럴 ``...${*표현식*}...``
    2. 문자열을 여러 줄에 걸쳐 작성 가능
    3. 태그드 템플릿
    - 태그를 사용하여 템플릿 리터럴을 함수로 파싱
    - 데이터 별로 상황(조건)이 다른 경우 유용함
        
        ```jsx
        const ramenList = [
            {
                brand: '농심',
                items: ['신라면','짜파게티','참치마요','둥지냉면']
            },
            {
                brand: '삼양',
                items: ['삼양라면', '불닭볶음면']
            },
            {
                brand: '오뚜기',
                itmes: []
            }
        ];
        
        console.log(`구매가능한 ${ramenList[0].brand}의 라면 : ${ramenList[0].items}`);
        //구매가능한 농심의 라면 : 신라면,짜파게티,참치마요,둥지냉면
        console.log(`구매가능한 ${ramenList[1].brand}의 라면 : ${ramenList[1].items}`);
        //구매가능한 삼양의 라면 : 삼양라면,불닭볶음면
        console.log(`구매가능한 ${ramenList[2].brand}의 라면 : ${ramenList[2].items}`);
        //구매가능한 오뚜기의 라면 : undefined
        
        // 태그드 템플릿 예시
        function fn(strings, brand, items) {
            if(undefined === items) {
                return brand + "의 라면은 재고가 없습니다!";
            } else {
                return strings[0] + brand + strings[1] + items;
            }
        }
        
        console.log(fn`구매가능한 ${ramenList[0].brand}의 라면 : ${ramenList[0].items}`);
        //구매가능한 농심의 라면 : 신라면,짜파게티,참치마요,둥지냉면
        console.log(fn`구매가능한 ${ramenList[1].brand}의 라면 : ${ramenList[1].items}`);
        //구매가능한 삼양의 라면 : 삼양라면,불닭볶음면
        console.log(fn`구매가능한 ${ramenList[2].brand}의 라면 : ${ramenList[2].items}`);
        //오뚜기의 라면은 재고가 없습니다!
        ```
        
- 특수 기호
    - 특수 문자 종류
        
        `\n` `\r` (`\r\n`) `\'`, `\"` `\\` `\t` `\b`, `\f`, `\v` `\xXX` `\uXXXX` 등
        
- 문자열 길이 — `length` 프로퍼티
- 문자열 앞과 끝 공백 문자 제거 — `str.trim()`
- 문자열 n번 반복 — `str.repeat(n)`
- 특정 글자에 접근하는 법 — `*str*[*0*]`, `*str*.charAt(*0*)`
마지막 글자 접근 ⇒ `str[str.length - 1]`
- `for…of` 문 사용 가능
- 문자열 구성하는 글자 대상으로 반복
- 부분 문자열 찾기 — `str.indexOf(substr, pos)`
반복문 안에 indexOf를 사용하면, 
문자열 내 부분 문자열 전체를 대상으로 무언가를 할 수 있다
    
    ```jsx
    let str = "As sly as a fox, as strong as an ox";
    let target = "as";
    
    let pos = -1;
    while ((pos = str.indexOf(target, pos + 1)) != -1) {
      alert( `위치: ${pos}` );
    } // 위치: 7, 위치: 17, 위치: 27
    ```
    
    부분 문자열 여부를 검사할 땐 `-1`과 비교해야 함
    
- 문자열 끝에서부터 부분 문자열 찾기 — `str.lastIndexOf(substr, position)`
- 비트 NOT 연산자 `~`
피연산자를 32비트 정수로 바꾼 후(소수부는 모두 버려짐) 모든 비트를 반전
    
    “`if (~str.indexOf(...))` 패턴의 코드를 만나면 '부분 문자열인지 확인’하는 코드라고 기억해둡시다”
    
- `str.includes(substr, pos)` — str에 부분 문자열 substr이 있는지에 따라 불린 형태로 반환
부분 문자열의 포함 여부만 알고 싶을 때 적합한 메서드 (cf. indexOf)
- `str.startsWith` / `str.endsWith` — 문자열 str 이 특정 문자열로 시작하는지 / 끝나는지 여부 확인
- 부분 문자열 추출
    - `str.slice(start [, end])` — 문자열을 start부터 end까지 반환
    end는 미포함
    음수 인수 가능(문자열 끝에서부터 카운팅)
    - `str.substring(start [, end])` — start와 end 사이에 있는 문자열 반환
    음수 인수 허용 안함. 음수는 0 처리
    - ~~str.substr(start [, length]) — start부터 시작해 length 개의 글자를 반환
    음수 인수 가능~~
- 문자열 비교
    1. 소문자는 대문자보다 항상 크다 
    2. 발음 구별 기호가 붙은 문자는 알파벳 순서 기준을 따르지 않는다
    - `str.localeCompare(str2)`
 
# 💡새로 알게 된 것

- Number(), String(), Boolean() 이 “원시 래퍼 객체” 였다는 것
- `NaN`은 `NaN` 자기 자신을 포함하여 그 어떤 값과도 같지 않다는 점
- 접근하려는 위치에 글자가 없는 경우 
`[]`는 `undefined` 반환 
`charAt`은 빈 문자열 반환

# 👀 궁금한 것

- 윈시 래퍼 객체의 메모리는 스택에 저장되나요? 힙에 저장되나요?
- 숫자형 본문에서 무한소수를 계산할 완벽한 방법은 없다지만, toFixed()로 계산할 수 있다고 합니다. [숫자형 문제 2](https://ko.javascript.info/task/why-rounded-down)에서는 toFixed전에도 정수에 가깝게 만든 후 거듭제곱으로 나눠야 한다고 하는데요, 소수를 대할 때(반올림하거나 사칙연산 등) 매번 두가지 방법 모두를 써야하나요?
- 진수들과 그 변환에 대해 잘 알고있어야 할까요?
ex. 90을 16진수로 변환하면 5a 이다
